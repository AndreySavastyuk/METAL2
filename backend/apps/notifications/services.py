"""
–°–µ—Ä–≤–∏—Å—ã –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
"""
import logging
from typing import Optional, Dict, Any, List
from datetime import datetime, date
from django.conf import settings
from django.contrib.auth.models import User
from django.utils import timezone
from django.db.models import Count, Q
from telegram import Bot
from telegram.error import TelegramError, Forbidden, BadRequest
import asyncio
from .models import UserNotificationPreferences, NotificationLog

logger = logging.getLogger(__name__)


class TelegramNotificationService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤ Telegram"""
    
    def __init__(self):
        self.bot_token = settings.TELEGRAM_BOT_TOKEN
        self.bot = None
        if self.bot_token:
            self.bot = Bot(token=self.bot_token)
    
    def _check_bot_available(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –±–æ—Ç–∞"""
        if not self.bot_token:
            logger.warning("TELEGRAM_BOT_TOKEN –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
            return False
        
        if not self.bot:
            logger.error("Telegram Bot –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            return False
        
        return True
    
    def _get_user_preferences(self, user: User) -> Optional[UserNotificationPreferences]:
        """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            return user.notification_preferences
        except UserNotificationPreferences.DoesNotExist:
            # –°–æ–∑–¥–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            return UserNotificationPreferences.objects.create(
                user=user,
                notification_types={
                    'status_update': {'enabled': True, 'urgent_only': False},
                    'task_assignment': {'enabled': True, 'urgent_only': False},
                    'urgent_alert': {'enabled': True, 'urgent_only': False},
                }
            )
    
    def _create_notification_log(self, user: User, notification_type: str, 
                               message: str, chat_id: str, 
                               object_type: str = None, object_id: int = None) -> NotificationLog:
        """–°–æ–∑–¥–∞—Ç—å –∑–∞–ø–∏—Å—å –≤ –ª–æ–≥–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
        return NotificationLog.objects.create(
            user=user,
            notification_type=notification_type,
            message=message,
            telegram_chat_id=chat_id,
            object_type=object_type,
            object_id=object_id
        )
    
    def _format_material_info(self, material) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –º–∞—Ç–µ—Ä–∏–∞–ª–µ"""
        return (
            f"üì¶ *–ú–∞—Ç–µ—Ä–∏–∞–ª:* {material.material_grade}\n"
            f"üè≠ *–ü–æ—Å—Ç–∞–≤—â–∏–∫:* {material.supplier}\n"
            f"üìÑ *–°–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç:* {material.certificate_number}\n"
            f"üî• *–ü–ª–∞–≤–∫–∞:* {material.heat_number}\n"
            f"üìè *–†–∞–∑–º–µ—Ä:* {material.size}\n"
            f"‚öñÔ∏è *–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:* {material.quantity} {material.get_unit_display()}"
        )
    
    def send_status_update(self, user_id: int, material, old_status: str, 
                          new_status: str, is_urgent: bool = False) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞"""
        if not self._check_bot_available():
            return False
        
        try:
            user = User.objects.get(id=user_id)
            preferences = self._get_user_preferences(user)
            
            if not preferences.should_send_notification('status_update', is_urgent):
                logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ç–∞—Ç—É—Å–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.username}")
                return False
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            status_emoji = {
                'pending_qc': '‚è≥',
                'in_qc': 'üîç',
                'approved': '‚úÖ',
                'rejected': '‚ùå',
                'in_lab': 'üß™',
                'lab_complete': '‚úÖ',
                'in_production': '‚öôÔ∏è',
                'completed': 'üéâ'
            }
            
            old_emoji = status_emoji.get(old_status, 'üìã')
            new_emoji = status_emoji.get(new_status, 'üìã')
            
            # –ü–µ—Ä–µ–≤–æ–¥–∏–º —Å—Ç–∞—Ç—É—Å—ã –Ω–∞ —Ä—É—Å—Å–∫–∏–π
            status_translations = {
                'pending_qc': '–û–∂–∏–¥–∞–µ—Ç –û–¢–ö',
                'in_qc': '–í –û–¢–ö',
                'approved': '–û–¥–æ–±—Ä–µ–Ω–æ',
                'rejected': '–û—Ç–∫–ª–æ–Ω–µ–Ω–æ',
                'in_lab': '–í –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–∏',
                'lab_complete': '–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞',
                'in_production': '–í –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤–µ',
                'completed': '–ó–∞–≤–µ—Ä—à–µ–Ω–æ'
            }
            
            old_status_ru = status_translations.get(old_status, old_status)
            new_status_ru = status_translations.get(new_status, new_status)
            
            message = (
                f"üîÑ *–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –º–∞—Ç–µ—Ä–∏–∞–ª–∞*\n\n"
                f"{self._format_material_info(material)}\n\n"
                f"üìä *–°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω:*\n"
                f"{old_emoji} {old_status_ru} ‚Üí {new_emoji} {new_status_ru}\n\n"
                f"üïê *–í—Ä–µ–º—è:* {timezone.now().strftime('%d.%m.%Y %H:%M')}"
            )
            
            if is_urgent:
                message = f"üö® *–°–†–û–ß–ù–û!* üö®\n\n{message}"
            
            # –°–æ–∑–¥–∞–µ–º –ª–æ–≥
            log = self._create_notification_log(
                user=user,
                notification_type='status_update',
                message=message,
                chat_id=preferences.telegram_chat_id,
                object_type='material',
                object_id=material.id
            )
            
            from .tasks import send_telegram_message
            send_telegram_message.delay(log.id)
            
            return True
            
        except User.DoesNotExist:
            logger.error(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å—Ç–∞—Ç—É—Å–µ: {e}")
            return False
    
    def send_task_assignment(self, user_id: int, task_type: str, 
                           material, additional_info: str = "", 
                           is_urgent: bool = False) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ –∑–∞–¥–∞—á–∏"""
        if not self._check_bot_available():
            return False
        
        try:
            user = User.objects.get(id=user_id)
            preferences = self._get_user_preferences(user)
            
            if not preferences.should_send_notification('task_assignment', is_urgent):
                logger.info(f"–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–¥–∞—á–∞—Ö –æ—Ç–∫–ª—é—á–µ–Ω—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.username}")
                return False
            
            # –ü–µ—Ä–µ–≤–æ–¥–∏–º —Ç–∏–ø—ã –∑–∞–¥–∞—á
            task_translations = {
                'qc_inspection': '–ü—Ä–æ–≤–µ—Ä–∫–∞ –û–¢–ö',
                'lab_testing': '–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ã–µ –∏—Å–ø—ã—Ç–∞–Ω–∏—è',
                'production_prep': '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤—É',
                'final_inspection': '–§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞',
                'warehouse_receipt': '–ü—Ä–∏–µ–º–∫–∞ –Ω–∞ —Å–∫–ª–∞–¥'
            }
            
            task_emojis = {
                'qc_inspection': 'üîç',
                'lab_testing': 'üß™',
                'production_prep': '‚öôÔ∏è',
                'final_inspection': 'üìã',
                'warehouse_receipt': 'üì¶'
            }
            
            task_ru = task_translations.get(task_type, task_type)
            task_emoji = task_emojis.get(task_type, 'üìã')
            
            message = (
                f"{task_emoji} *–ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –Ω–∞–∑–Ω–∞—á–µ–Ω–∞*\n\n"
                f"üë§ *–ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å:* {user.get_full_name() or user.username}\n"
                f"üìã *–¢–∏–ø –∑–∞–¥–∞—á–∏:* {task_ru}\n\n"
                f"{self._format_material_info(material)}\n\n"
                f"üïê *–í—Ä–µ–º—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è:* {timezone.now().strftime('%d.%m.%Y %H:%M')}"
            )
            
            if additional_info:
                message += f"\n\nüìù *–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:*\n{additional_info}"
            
            if is_urgent:
                message = f"üö® *–°–†–û–ß–ù–ê–Ø –ó–ê–î–ê–ß–ê!* üö®\n\n{message}"
            
            # –°–æ–∑–¥–∞–µ–º –ª–æ–≥
            log = self._create_notification_log(
                user=user,
                notification_type='task_assignment',
                message=message,
                chat_id=preferences.telegram_chat_id,
                object_type='material',
                object_id=material.id
            )
            
            from .tasks import send_telegram_message
            send_telegram_message.delay(log.id)
            
            return True
            
        except User.DoesNotExist:
            logger.error(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –∑–∞–¥–∞—á–µ: {e}")
            return False
    
    def send_daily_summary(self, user_id: int, summary_date: date = None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—É—é —Å–≤–æ–¥–∫—É"""
        if not self._check_bot_available():
            return False
        
        try:
            user = User.objects.get(id=user_id)
            preferences = self._get_user_preferences(user)
            
            if not preferences.should_send_notification('daily_summary'):
                logger.info(f"–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å–≤–æ–¥–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.username}")
                return False
            
            if summary_date is None:
                summary_date = timezone.now().date()
            
            # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞ –¥–µ–Ω—å
            from apps.warehouse.models import MaterialReceipt
            from apps.quality.models import QCInspection
            from apps.laboratory.models import TestRequest
            
            start_date = timezone.make_aware(datetime.combine(summary_date, datetime.min.time()))
            end_date = timezone.make_aware(datetime.combine(summary_date, datetime.max.time()))
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è–º
            receipts_count = MaterialReceipt.objects.filter(
                created_at__range=[start_date, end_date]
            ).count()
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø—Ä–æ–≤–µ—Ä–∫–∞–º –û–¢–ö
            qc_inspections = QCInspection.objects.filter(
                created_at__range=[start_date, end_date]
            ).aggregate(
                total=Count('id'),
                approved=Count('id', filter=Q(status='approved')),
                rejected=Count('id', filter=Q(status='rejected'))
            )
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ã–º –∏—Å–ø—ã—Ç–∞–Ω–∏—è–º
            lab_tests = TestRequest.objects.filter(
                created_at__range=[start_date, end_date]
            ).aggregate(
                total=Count('id'),
                completed=Count('id', filter=Q(status='completed'))
            )
            
            message = (
                f"üìä *–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Å–≤–æ–¥–∫–∞ –∑–∞ {summary_date.strftime('%d.%m.%Y')}*\n\n"
                f"üì¶ *–ü–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤:* {receipts_count}\n\n"
                f"üîç *–ü—Ä–æ–≤–µ—Ä–∫–∏ –û–¢–ö:*\n"
                f"  ‚Ä¢ –í—Å–µ–≥–æ: {qc_inspections['total']}\n"
                f"  ‚Ä¢ –û–¥–æ–±—Ä–µ–Ω–æ: {qc_inspections['approved']} ‚úÖ\n"
                f"  ‚Ä¢ –û—Ç–∫–ª–æ–Ω–µ–Ω–æ: {qc_inspections['rejected']} ‚ùå\n\n"
                f"üß™ *–õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ã–µ –∏—Å–ø—ã—Ç–∞–Ω–∏—è:*\n"
                f"  ‚Ä¢ –í—Å–µ–≥–æ: {lab_tests['total']}\n"
                f"  ‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: {lab_tests['completed']} ‚úÖ\n\n"
                f"üïê *–í—Ä–µ–º—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è:* {timezone.now().strftime('%d.%m.%Y %H:%M')}"
            )
            
            # –°–æ–∑–¥–∞–µ–º –ª–æ–≥
            log = self._create_notification_log(
                user=user,
                notification_type='daily_summary',
                message=message,
                chat_id=preferences.telegram_chat_id
            )
            
            from .tasks import send_telegram_message
            send_telegram_message.delay(log.id)
            
            return True
            
        except User.DoesNotExist:
            logger.error(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ–π —Å–≤–æ–¥–∫–∏: {e}")
            return False
    
    def send_urgent_alert(self, user_ids: List[int], alert_type: str, 
                         message: str, material=None) -> bool:
        """–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å—Ä–æ—á–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≥—Ä—É–ø–ø–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
        if not self._check_bot_available():
            return False
        
        success_count = 0
        
        for user_id in user_ids:
            try:
                user = User.objects.get(id=user_id)
                preferences = self._get_user_preferences(user)
                
                if not preferences.should_send_notification('urgent_alert', is_urgent=True):
                    continue
                
                alert_message = f"üö® *–°–†–û–ß–ù–û–ï –£–í–ï–î–û–ú–õ–ï–ù–ò–ï* üö®\n\n"
                alert_message += f"‚ö†Ô∏è *–¢–∏–ø:* {alert_type}\n\n"
                alert_message += f"üìù *–°–æ–æ–±—â–µ–Ω–∏–µ:*\n{message}\n\n"
                
                if material:
                    alert_message += f"{self._format_material_info(material)}\n\n"
                
                alert_message += f"üïê *–í—Ä–µ–º—è:* {timezone.now().strftime('%d.%m.%Y %H:%M')}"
                
                # –°–æ–∑–¥–∞–µ–º –ª–æ–≥
                log = self._create_notification_log(
                    user=user,
                    notification_type='urgent_alert',
                    message=alert_message,
                    chat_id=preferences.telegram_chat_id,
                    object_type='material' if material else None,
                    object_id=material.id if material else None
                )
                
                from .tasks import send_telegram_message
                send_telegram_message.delay(log.id)
                success_count += 1
                
            except User.DoesNotExist:
                logger.error(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID {user_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")
                continue
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å—Ä–æ—á–Ω–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")
                continue
        
        logger.info(f"–°—Ä–æ—á–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {success_count} –∏–∑ {len(user_ids)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
        return success_count > 0


# Singleton instance
telegram_service = TelegramNotificationService()